{"version":3,"sources":["../src/datemath.js"],"names":["isMathString","parse","isValid","parseDateMath","units","text","substring","includes","roundUp","timezone","undefined","_","isDate","time","mathString","index","parseString","length","indexOf","ISO_8601","date","strippedMathString","replace","dateTime","i","len","c","charAt","type","num","unit","isNaN","parseInt","numFrom","endOf","startOf","add","subtract"],"mappings":";;;;;QAMgBA,Y,GAAAA,Y;QAmBAC,K,GAAAA,K;QAiDAC,O,GAAAA,O;QAoBAC,a,GAAAA,a;;AA9FhB;;;;AAEA;;;;AAEA,IAAMC,QAAQ,CAAC,GAAD,EAAM,GAAN,EAAW,GAAX,EAAgB,GAAhB,EAAqB,GAArB,EAA0B,GAA1B,EAA+B,GAA/B,CAAd;;AAEO,SAASJ,YAAT,CAAsBK,IAAtB,EAA4B;AACjC,MAAI,CAACA,IAAL,EAAW;AACT,WAAO,KAAP;AACD;;AAED,MAAI,OAAOA,IAAP,KAAgB,QAAhB,KAA6BA,KAAKC,SAAL,CAAe,CAAf,EAAkB,CAAlB,MAAyB,KAAzB,IAAkCD,KAAKE,QAAL,CAAc,IAAd,CAA/D,CAAJ,EAAyF;AACvF,WAAO,IAAP;AACD,GAFD,MAEO;AACL,WAAO,KAAP;AACD;AACF;;AAED;;;;;;;AAOO,SAASN,KAAT,CAAeI,IAAf,EAAqBG,OAArB,EAA8BC,QAA9B,EAAwC;AAC7C,MAAI,CAACJ,IAAL,EAAW;AACT,WAAOK,SAAP;AACD;;AAED,MAAI,OAAOL,IAAP,KAAgB,QAApB,EAA8B;AAC5B,QAAI,gCAAWA,IAAX,CAAJ,EAAsB;AACpB,aAAOA,IAAP;AACD;AACD,QAAIM,iBAAEC,MAAF,CAASP,IAAT,CAAJ,EAAoB;AAClB,aAAO,8BAASA,IAAT,CAAP;AACD;AACD;AACA,WAAOK,SAAP;AACD,GATD,MASO;AACL,QAAIG,aAAJ;AACA,QAAIC,aAAa,EAAjB;AACA,QAAIC,cAAJ;AACA,QAAIC,oBAAJ;;AAEA,QAAIX,KAAKC,SAAL,CAAe,CAAf,EAAkB,CAAlB,MAAyB,KAA7B,EAAoC;AAClCO,aAAO,yCAAoBJ,QAApB,CAAP;AACAK,mBAAaT,KAAKC,SAAL,CAAe,MAAMW,MAArB,CAAb;AACD,KAHD,MAGO;AACLF,cAAQV,KAAKa,OAAL,CAAa,IAAb,CAAR;AACA,UAAIH,UAAU,CAAC,CAAf,EAAkB;AAChBC,sBAAcX,IAAd;AACAS,qBAAa,EAAb,CAFgB,CAEC;AAClB,OAHD,MAGO;AACLE,sBAAcX,KAAKC,SAAL,CAAe,CAAf,EAAkBS,KAAlB,CAAd;AACAD,qBAAaT,KAAKC,SAAL,CAAeS,QAAQ,CAAvB,CAAb;AACD;AACD;AACAF,aAAO,8BAASG,WAAT,EAAsBG,wBAAtB,CAAP;AACD;;AAED,QAAI,CAACL,WAAWG,MAAhB,EAAwB;AACtB,aAAOJ,IAAP;AACD;;AAED,WAAOV,cAAcW,UAAd,EAA0BD,IAA1B,EAAgCL,OAAhC,CAAP;AACD;AACF;;AAED;;;;;AAKO,SAASN,OAAT,CAAiBG,IAAjB,EAAuB;AAC5B,MAAMe,OAAOnB,MAAMI,IAAN,CAAb;AACA,MAAI,CAACe,IAAL,EAAW;AACT,WAAO,KAAP;AACD;;AAED,MAAI,gCAAWA,IAAX,CAAJ,EAAsB;AACpB,WAAOA,KAAKlB,OAAL,EAAP;AACD;;AAED,SAAO,KAAP;AACD;;AAED;;;;;;AAMA;AACO,SAASC,aAAT,CAAuBW,UAAvB,EAAmCD,IAAnC,EAAyCL,OAAzC,EAAkD;AACvD,MAAMa,qBAAqBP,WAAWQ,OAAX,CAAmB,KAAnB,EAA0B,EAA1B,CAA3B;AACA,MAAMC,WAAWV,IAAjB;AACA,MAAIW,IAAI,CAAR;AACA,MAAMC,MAAMJ,mBAAmBJ,MAA/B;;AAEA,SAAOO,IAAIC,GAAX,EAAgB;AACd,QAAMC,IAAIL,mBAAmBM,MAAnB,CAA0BH,GAA1B,CAAV;AACA,QAAII,aAAJ;AACA,QAAIC,YAAJ;AACA,QAAIC,aAAJ;;AAEA,QAAIJ,MAAM,GAAV,EAAe;AACbE,aAAO,CAAP;AACD,KAFD,MAEO,IAAIF,MAAM,GAAV,EAAe;AACpBE,aAAO,CAAP;AACD,KAFM,MAEA,IAAIF,MAAM,GAAV,EAAe;AACpBE,aAAO,CAAP;AACD,KAFM,MAEA;AACL,aAAOlB,SAAP;AACD;;AAED,QAAIqB,MAAMC,SAASX,mBAAmBM,MAAnB,CAA0BH,CAA1B,CAAT,EAAuC,EAAvC,CAAN,CAAJ,EAAuD;AACrDK,YAAM,CAAN;AACD,KAFD,MAEO,IAAIR,mBAAmBJ,MAAnB,KAA8B,CAAlC,EAAqC;AAC1CY,YAAMR,mBAAmBM,MAAnB,CAA0BH,CAA1B,CAAN;AACD,KAFM,MAEA;AACL,UAAMS,UAAUT,CAAhB;AACA,aAAO,CAACO,MAAMC,SAASX,mBAAmBM,MAAnB,CAA0BH,CAA1B,CAAT,EAAuC,EAAvC,CAAN,CAAR,EAA2D;AACzDA;AACA,YAAIA,IAAI,EAAR,EAAY;AACV,iBAAOd,SAAP;AACD;AACF;AACDmB,YAAMG,SAASX,mBAAmBf,SAAnB,CAA6B2B,OAA7B,EAAsCT,CAAtC,CAAT,EAAmD,EAAnD,CAAN;AACD;;AAED,QAAII,SAAS,CAAb,EAAgB;AACd;AACA,UAAIC,QAAQ,CAAZ,EAAe;AACb,eAAOnB,SAAP;AACD;AACF;AACDoB,WAAOT,mBAAmBM,MAAnB,CAA0BH,GAA1B,CAAP;;AAEA,QAAI,CAACb,iBAAEJ,QAAF,CAAWH,KAAX,EAAkB0B,IAAlB,CAAL,EAA8B;AAC5B,aAAOpB,SAAP;AACD,KAFD,MAEO;AACL,UAAIkB,SAAS,CAAb,EAAgB;AACd,YAAIpB,OAAJ,EAAa;AACXe,mBAASW,KAAT,CAAeJ,IAAf;AACD,SAFD,MAEO;AACLP,mBAASY,OAAT,CAAiBL,IAAjB;AACD;AACF,OAND,MAMO,IAAIF,SAAS,CAAb,EAAgB;AACrBL,iBAASa,GAAT,CAAaP,GAAb,EAAkBC,IAAlB;AACD,OAFM,MAEA,IAAIF,SAAS,CAAb,EAAgB;AACrBL,iBAASc,QAAT,CAAkBR,GAAlB,EAAuBC,IAAvB;AACD;AACF;AACF;AACD,SAAOP,QAAP;AACD","file":"datemath.js","sourcesContent":["import _ from 'lodash';\n\nimport { dateTime, dateTimeForTimeZone, ISO_8601, isDateTime } from './moment_wrapper';\n\nconst units = ['y', 'M', 'w', 'd', 'h', 'm', 's'];\n\nexport function isMathString(text) {\n  if (!text) {\n    return false;\n  }\n\n  if (typeof text === 'string' && (text.substring(0, 3) === 'now' || text.includes('||'))) {\n    return true;\n  } else {\n    return false;\n  }\n}\n\n/**\n * Parses different types input to a moment instance. There is a specific formatting language that can be used\n * if text arg is string. See unit tests for examples.\n * @param text\n * @param roundUp See parseDateMath function.\n * @param timezone Only string 'utc' is acceptable here, for anything else, local timezone is used.\n */\nexport function parse(text, roundUp, timezone) {\n  if (!text) {\n    return undefined;\n  }\n\n  if (typeof text !== 'string') {\n    if (isDateTime(text)) {\n      return text;\n    }\n    if (_.isDate(text)) {\n      return dateTime(text);\n    }\n    // We got some non string which is not a moment nor Date. TS should be able to check for that but not always.\n    return undefined;\n  } else {\n    let time;\n    let mathString = '';\n    let index;\n    let parseString;\n\n    if (text.substring(0, 3) === 'now') {\n      time = dateTimeForTimeZone(timezone);\n      mathString = text.substring('now'.length);\n    } else {\n      index = text.indexOf('||');\n      if (index === -1) {\n        parseString = text;\n        mathString = ''; // nothing else\n      } else {\n        parseString = text.substring(0, index);\n        mathString = text.substring(index + 2);\n      }\n      // We're going to just require ISO8601 timestamps, k?\n      time = dateTime(parseString, ISO_8601);\n    }\n\n    if (!mathString.length) {\n      return time;\n    }\n\n    return parseDateMath(mathString, time, roundUp);\n  }\n}\n\n/**\n * Checks if text is a valid date which in this context means that it is either a Moment instance or it can be parsed\n * by parse function. See parse function to see what is considered acceptable.\n * @param text\n */\nexport function isValid(text) {\n  const date = parse(text);\n  if (!date) {\n    return false;\n  }\n\n  if (isDateTime(date)) {\n    return date.isValid();\n  }\n\n  return false;\n}\n\n/**\n * Parses math part of the time string and shifts supplied time according to that math. See unit tests for examples.\n * @param mathString\n * @param time\n * @param roundUp If true it will round the time to endOf time unit, otherwise to startOf time unit.\n */\n// TODO: Had to revert Andrejs `time: moment.Moment` to `time: any`\nexport function parseDateMath(mathString, time, roundUp) {\n  const strippedMathString = mathString.replace(/\\s/g, '');\n  const dateTime = time;\n  let i = 0;\n  const len = strippedMathString.length;\n\n  while (i < len) {\n    const c = strippedMathString.charAt(i++);\n    let type;\n    let num;\n    let unit;\n\n    if (c === '/') {\n      type = 0;\n    } else if (c === '+') {\n      type = 1;\n    } else if (c === '-') {\n      type = 2;\n    } else {\n      return undefined;\n    }\n\n    if (isNaN(parseInt(strippedMathString.charAt(i), 10))) {\n      num = 1;\n    } else if (strippedMathString.length === 2) {\n      num = strippedMathString.charAt(i);\n    } else {\n      const numFrom = i;\n      while (!isNaN(parseInt(strippedMathString.charAt(i), 10))) {\n        i++;\n        if (i > 10) {\n          return undefined;\n        }\n      }\n      num = parseInt(strippedMathString.substring(numFrom, i), 10);\n    }\n\n    if (type === 0) {\n      // rounding is only allowed on whole, single, units (eg M or 1M, not 0.5M or 2M)\n      if (num !== 1) {\n        return undefined;\n      }\n    }\n    unit = strippedMathString.charAt(i++);\n\n    if (!_.includes(units, unit)) {\n      return undefined;\n    } else {\n      if (type === 0) {\n        if (roundUp) {\n          dateTime.endOf(unit);\n        } else {\n          dateTime.startOf(unit);\n        }\n      } else if (type === 1) {\n        dateTime.add(num, unit);\n      } else if (type === 2) {\n        dateTime.subtract(num, unit);\n      }\n    }\n  }\n  return dateTime;\n}"]}