{"version":3,"sources":["../src/query_builder.js"],"names":["renderTagCondition","tag","index","str","operator","value","condition","test","isNaN","key","SplunkQueryBuilder","target","type","withKey","withMeasurementFilter","query","measurement","kbn","regexEscape","match","database","tags","length","whereConditions","_","reduce","memo","push","join"],"mappings":";;;;;;;;;AAAA;;AACA;;;;AAEA,SAASA,kBAAT,CAA4BC,GAA5B,EAAiCC,KAAjC,EAAwC;AACtC,MAAIC,MAAM,EAAV;AACA,MAAIC,WAAWH,IAAIG,QAAnB;AACA,MAAIC,QAAQJ,IAAII,KAAhB;AACA,MAAIH,QAAQ,CAAZ,EAAe;AACbC,UAAM,CAACF,IAAIK,SAAJ,IAAiB,KAAlB,IAA2B,GAAjC;AACD;;AAED,MAAI,CAACF,QAAL,EAAe;AACb,QAAI,WAAWG,IAAX,CAAgBN,IAAII,KAApB,CAAJ,EAAgC;AAC9BD,iBAAW,IAAX;AACD,KAFD,MAEO;AACLA,iBAAW,GAAX;AACD;AACF;;AAED;AACA,MAAIA,aAAa,IAAb,IAAqBA,aAAa,IAAlC,IAA0CI,MAAM,CAACH,KAAP,CAA9C,EAA6D;AAC3DA,YAAQ,MAAMA,KAAN,GAAc,GAAtB;AACD;;AAED,SAAOF,MAAM,GAAN,GAAYF,IAAIQ,GAAhB,GAAsB,IAAtB,GAA6BL,QAA7B,GAAwC,GAAxC,GAA8CC,KAArD;AACD;;IAEYK,kB,WAAAA,kB;AACX,8BAAYC,MAAZ,EAAoB;AAAA;AAAE;;;;sCAEJC,I,EAAMC,O,EAASC,qB,EAAuB;AACtD,UAAIC,cAAJ;AACA,UAAIC,oBAAJ;AACA,UAAId,cAAJ;;AAEA,UAAIU,SAAS,aAAb,EAA4B;AAC1BG,gBAAQ,0BAAR;AACAC,sBAAc,KAAKL,MAAL,CAAYK,WAA1B;AACAd,gBAAQ,KAAKS,MAAL,CAAYT,KAApB;AACD,OAJD,MAIO,IAAIU,SAAS,cAAb,EAA6B;AAClCG,gBAAQ,qBAAR;AACAC,sBAAc,KAAKL,MAAL,CAAYK,WAA1B;AACAd,gBAAQ,KAAKS,MAAL,CAAYT,KAApB;AACD,OAJM,MAIA,IAAIU,SAAS,cAAb,EAA6B;AAClCG,gBAAQ,gCAAR;AACA,YAAID,qBAAJ,EAA2B;AACzBC,mBAAS,4BAA4BE,SAAIC,WAAJ,CAAgBJ,qBAAhB,CAA5B,GAAqE,GAA9E;AACD;AACF,OALM,MAKA,IAAIF,SAAS,QAAb,EAAuB;AAC5BI,sBAAc,KAAKL,MAAL,CAAYK,WAA1B;AACAd,gBAAQ,KAAKS,MAAL,CAAYT,KAApB;;AAEA,YAAI,CAACc,YAAYG,KAAZ,CAAkB,OAAlB,CAAL,EAAiC;AAC/BH,wBAAc,MAAMA,WAAN,GAAoB,GAAlC;;AAEA,cAAId,SAASA,UAAU,SAAvB,EAAkC;AAChCA,oBAAQ,MAAMA,KAAN,GAAc,GAAtB;AACAc,0BAAcd,QAAQ,GAAR,GAAcc,WAA5B;AACD;AACF;;AAED,eAAO,0BAA0BA,WAAjC;AACD,OAdM,MAcA,IAAIJ,SAAS,SAAb,EAAwB;AAC7BG,gBAAQ,2CAA2C,KAAKK,QAAhD,GAA2D,kBAAnE;AACA,eAAOL,KAAP;AACD;;AAED,UAAIC,WAAJ,EAAiB;AACf,YAAI,CAACA,YAAYG,KAAZ,CAAkB,OAAlB,CAAD,IAA+B,CAACH,YAAYG,KAAZ,CAAkB,cAAlB,CAApC,EAAuE;AACrEH,wBAAc,MAAMA,WAAN,GAAoB,GAAlC;AACD;;AAED,YAAId,SAASA,UAAU,SAAvB,EAAkC;AAChCA,kBAAQ,MAAMA,KAAN,GAAc,GAAtB;AACAc,wBAAcd,QAAQ,GAAR,GAAcc,WAA5B;AACD;;AAEDD,iBAAS,YAAYC,WAArB;AACD;;AAED,UAAIH,OAAJ,EAAa;AACXE,iBAAS,kBAAkBF,OAAlB,GAA4B,GAArC;AACD;;AAED,UAAI,KAAKF,MAAL,CAAYU,IAAZ,IAAoB,KAAKV,MAAL,CAAYU,IAAZ,CAAiBC,MAAjB,GAA0B,CAAlD,EAAqD;AACnD,YAAMC,kBAAkBC,UAAEC,MAAF,CACtB,KAAKd,MAAL,CAAYU,IADU,EAEtB,UAACK,IAAD,EAAOzB,GAAP,EAAe;AACb;AACA,cAAIA,IAAIQ,GAAJ,KAAYI,OAAhB,EAAyB;AACvB,mBAAOa,IAAP;AACD;AACDA,eAAKC,IAAL,CAAU3B,mBAAmBC,GAAnB,EAAwByB,KAAKJ,MAA7B,CAAV;AACA,iBAAOI,IAAP;AACD,SATqB,EAUtB,EAVsB,CAAxB;;AAaA,YAAIH,gBAAgBD,MAAhB,GAAyB,CAA7B,EAAgC;AAC9BP,mBAAS,YAAYQ,gBAAgBK,IAAhB,CAAqB,GAArB,CAArB;AACD;AACF;AACD,UAAIhB,SAAS,cAAb,EAA6B;AAC3BG,iBAAS,KAAT;AACA;AACA;AACA;AACD;AACD,aAAOA,KAAP;AACD","file":"query_builder.js","sourcesContent":["import { _ } from 'lodash';\nimport { kbn } from 'app/core/utils/kbn';\n\nfunction renderTagCondition(tag, index) {\n  let str = '';\n  let operator = tag.operator;\n  let value = tag.value;\n  if (index > 0) {\n    str = (tag.condition || 'AND') + ' ';\n  }\n\n  if (!operator) {\n    if (/^\\/.*\\/$/.test(tag.value)) {\n      operator = '=~';\n    } else {\n      operator = '=';\n    }\n  }\n\n  // quote value unless regex or number\n  if (operator !== '=~' && operator !== '!~' && isNaN(+value)) {\n    value = \"'\" + value + \"'\";\n  }\n\n  return str + '\"' + tag.key + '\" ' + operator + ' ' + value;\n}\n\nexport class SplunkQueryBuilder {\n  constructor(target) {}\n\n  buildExploreQuery(type, withKey, withMeasurementFilter) {\n    let query;\n    let measurement;\n    let index;\n\n    if (type === 'FIELD_NAMES') {\n      query = '| mcatalog values(_dims)';\n      measurement = this.target.measurement;\n      index = this.target.index;\n    } else if (type === 'FIELD_VALUES') {\n      query = '| mcatalog values()';\n      measurement = this.target.measurement;\n      index = this.target.index;\n    } else if (type === 'METRIC_NAMES') {\n      query = '| mcatalog values(metric_name)';\n      if (withMeasurementFilter) {\n        query += ' where MEASUREMENT =~ /' + kbn.regexEscape(withMeasurementFilter) + '/';\n      }\n    } else if (type === 'FIELDS') {\n      measurement = this.target.measurement;\n      index = this.target.index;\n\n      if (!measurement.match('^/.*/')) {\n        measurement = '\"' + measurement + '\"';\n\n        if (index && index !== 'default') {\n          index = '\"' + index + '\"';\n          measurement = index + '.' + measurement;\n        }\n      }\n\n      return 'SHOW FIELD KEYS FROM ' + measurement;\n    } else if (type === 'INDEXES') {\n      query = '| mcatalog values(_dims) where index=\"' + this.database + '*\" | table index';\n      return query;\n    }\n\n    if (measurement) {\n      if (!measurement.match('^/.*/') && !measurement.match(/^merge\\(.*\\)/)) {\n        measurement = '\"' + measurement + '\"';\n      }\n\n      if (index && index !== 'default') {\n        index = '\"' + index + '\"';\n        measurement = index + '.' + measurement;\n      }\n\n      query += ' where ' + measurement;\n    }\n\n    if (withKey) {\n      query += ' WITH KEY = \"' + withKey + '\"';\n    }\n\n    if (this.target.tags && this.target.tags.length > 0) {\n      const whereConditions = _.reduce(\n        this.target.tags,\n        (memo, tag) => {\n          // do not add a condition for the key we want to explore for\n          if (tag.key === withKey) {\n            return memo;\n          }\n          memo.push(renderTagCondition(tag, memo.length));\n          return memo;\n        },\n        []\n      );\n\n      if (whereConditions.length > 0) {\n        query += ' WHERE ' + whereConditions.join(' ');\n      }\n    }\n    if (type === 'METRIC_NAMES') {\n      query += ' | ';\n      //Solve issue #2524 by limiting the number of measurements returned\n      //LIMIT must be after WITH MEASUREMENT and WHERE clauses\n      //This also could be used for TAG KEYS and TAG VALUES, if desired\n    }\n    return query;\n  }\n}"]}