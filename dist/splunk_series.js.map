{"version":3,"sources":["../src/splunk_series.js"],"names":["dateMath","SplunkSeries","options","results","alias","annotation","output","i","j","rows","length","columns","fields","time_column","indexOf","columnName","rowsName","datapoints","tz","split","time_string","slice","join","parseFloat","parse","valueOf","push","target","index","regex","segments","name","replace","match","g1","g2","group","segIndex","parseInt","isNaN","tag","tags","list","titleCol","timeCol","tagsCol","textCol","_","each","column","titleColumn","includes","tagsColumn","textColumn","data","time","Date","row","title","flatten","filter","t","map","text","table","TableModel","type","FieldType","values","reordered"],"mappings":"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","file":"splunk_series.js","sourcesContent":["import { _ } from 'lodash';\n\nimport * as dateMath from './datemath';\nimport { TableModel } from 'app/core/table_model';\nimport { FieldType } from '@grafana/ui';\n\nexport default class SplunkSeries {\n\n  constructor(options) {\n    this.results = options.results;\n    this.alias = options.alias;\n    this.annotation = options.annotation;\n  }\n\n  getTimeSeries() {\n    const output = [];\n    let i, j;\n\n    if (this.results.rows.length === 0) {\n      return output;\n    }\n\n    let results = this.results;\n    const columns = results.fields.length;\n    const time_column = results.fields.indexOf(\"_time\");\n    // const tags = _.map(results.tags, (value, key) => {\n    //   return key + ': ' + value;\n    // });\n\n    for (j = 0; j < columns; j++) {\n      if (j == time_column) {\n        continue\n      }\n      const columnName = results.fields[j];\n      let rowsName = columnName;\n\n      // if (this.alias) {\n      //   rowsName = this._getSeriesName(rows, j);\n      // } else if (rows.tags) {\n      //   rowsName = rowsName + ' {' + tags.join(', ') + '}';\n      // }\n\n      const datapoints = [];\n      if (results.rows) {\n        for (i = 0; i < results.rows.length; i++) {\n          let tz = results.rows[i][time_column].split(\" \")[-1];\n          let time_string = results.rows[i][time_column].split(\" \").slice(0,2).join(\" \");\n          datapoints[i] = [parseFloat(results.rows[i][j]), dateMath.parse(time_string, false, tz).valueOf()];\n        }\n      }\n\n      output.push({ target: rowsName, datapoints: datapoints });\n    }\n\n    return output;\n  }\n\n  _getSeriesName(rows, index) {\n    const regex = /\\$(\\w+)|\\[\\[([\\s\\S]+?)\\]\\]/g;\n    const segments = rows.name.split('.');\n\n    return this.alias.replace(regex, (match, g1, g2) => {\n      const group = g1 || g2;\n      const segIndex = parseInt(group, 10);\n\n      if (group === 'm' || group === 'measurement') {\n        return rows.name;\n      }\n      if (group === 'col') {\n        return rows.columns[index];\n      }\n      if (!isNaN(segIndex)) {\n        return segments[segIndex];\n      }\n      if (group.indexOf('tag_') !== 0) {\n        return match;\n      }\n\n      const tag = group.replace('tag_', '');\n      if (!rows.tags) {\n        return match;\n      }\n      return rows.tags[tag];\n    });\n  }\n\n  getAnnotations() {\n    const list = [];\n\n    let titleCol = null;\n    let timeCol = null;\n    const tagsCol = [];\n    let textCol = null;\n\n    _.each(this.results.fields, (column, index) => {\n      if (column === '_time') {\n        timeCol = index;\n        return;\n      }\n      if (column === 'sequence_number') {\n        return;\n      }\n      if (column === this.annotation.titleColumn) {\n        titleCol = index;\n        return;\n      }\n      if (_.includes((this.annotation.tagsColumn || '').replace(' ', '').split(','), column)) {\n        tagsCol.push(index);\n        return;\n      }\n      if (column === this.annotation.textColumn) {\n        textCol = index;\n        return;\n      }\n      // legacy case\n      if (!titleCol && textCol !== index) {\n        titleCol = index;\n      }\n    });\n\n    _.each(this.results.rows, row => {\n      const data = {\n        annotation: this.annotation,\n        time: +new Date(row[timeCol]),\n        title: row[titleCol],\n        // Remove empty rows, then split in different tags for comma separated rows\n        tags: _.flatten(\n          tagsCol\n            .filter(t => {\n              return row[t];\n            })\n            .map(t => {\n              return row[t].split(',');\n            })\n        ),\n        text: row[textCol],\n      };\n\n      list.push(data);\n    });\n\n    return list;\n  }\n\n  getTable() {\n    const table = new TableModel();\n    let i, j;\n\n    if (this.results.rows.length === 0) {\n      return table;\n    }\n\n    j = 0;\n    // Check that the first column is indeed 'time'\n    if (this.results.fields[0] === '_time') {\n      // Push this now before the tags and with the right type\n      table.columns.push({ text: 'Time', type: FieldType.time });\n      j++;\n    }\n    // _.each(_.keys(rows.tags), key => {\n    //   table.columns.push({ text: key });\n    // });\n    for (; j < this.results.fields.length; j++) {\n      table.columns.push({ text: this.results.fields[j] });\n    }\n\n    if (this.results.rows) {\n      for (i = 0; i < this.results.rows.length; i++) {\n        const values = this.results.rows[i];\n        const reordered = [values[0]];\n        // if (rows.tags) {\n        //   for (const key in rows.tags) {\n        //     if (rows.tags.hasOwnProperty(key)) {\n        //       reordered.push(rows.tags[key]);\n        //     }\n        //   }\n        // }\n        for (j = 1; j < values.length; j++) {\n          reordered.push(values[j]);\n        }\n        table.rows.push(reordered);\n      }\n    }\n\n    return table;\n  }\n}"]}